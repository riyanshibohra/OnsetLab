"""
Binary Export - Create standalone executable using PyInstaller.

Note: This creates a Python executable, NOT a fully standalone binary.
The user still needs Ollama running to use the agent.

For a truly standalone solution, use Docker export with include_ollama=True.
"""

import os
import sys
import shutil
import tempfile
from pathlib import Path
from typing import Optional

from .config_export import ConfigExporter


# Standalone script template
STANDALONE_SCRIPT = '''#!/usr/bin/env python3
"""
OnsetLab Standalone Agent
Generated by OnsetLab SDK

Requirements:
- Ollama must be running (ollama serve)
- Model must be pulled (ollama pull {model})
"""

import argparse
import sys

# Embedded configuration
CONFIG = {config}

def create_agent():
    """Create agent from embedded configuration."""
    try:
        from onsetlab import Agent
        from onsetlab.tools import Calculator, DateTime, UnitConverter, TextProcessor, RandomGenerator
    except ImportError:
        print("Error: OnsetLab not installed. Run: pip install onsetlab")
        sys.exit(1)
    
    TOOL_MAP = {{
        "Calculator": Calculator,
        "DateTime": DateTime,
        "UnitConverter": UnitConverter,
        "TextProcessor": TextProcessor,
        "RandomGenerator": RandomGenerator,
    }}
    
    tools = []
    for tool_config in CONFIG.get("tools", []):
        tool_class = TOOL_MAP.get(tool_config["class"])
        if tool_class:
            tools.append(tool_class())
    
    settings = CONFIG.get("onsetlab", {{}}).get("settings", {{}})
    
    try:
        agent = Agent(
            model=CONFIG.get("onsetlab", {{}}).get("model", "phi3.5"),
            tools=tools,
            memory=settings.get("memory", True),
            verify=settings.get("verify", True),
            routing=settings.get("routing", True),
            react_fallback=settings.get("react_fallback", True),
        )
    except RuntimeError as e:
        print(f"Error: {{e}}")
        print()
        print("Make sure Ollama is running:")
        print("  ollama serve")
        print(f"  ollama pull {{CONFIG.get('onsetlab', {{}}).get('model', 'phi3.5')}}")
        sys.exit(1)
    
    return agent

def main():
    parser = argparse.ArgumentParser(
        description="OnsetLab Agent",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                    # Interactive mode
  %(prog)s "What is 2+2?"     # Single query
  %(prog)s --serve            # API server mode
"""
    )
    parser.add_argument("query", nargs="?", help="Single query to run")
    parser.add_argument("--serve", action="store_true", help="Run as API server")
    parser.add_argument("--port", type=int, default=8000, help="Server port")
    args = parser.parse_args()
    
    agent = create_agent()
    
    if args.serve:
        try:
            from fastapi import FastAPI
            from pydantic import BaseModel
            import uvicorn
            
            app = FastAPI(title="OnsetLab Agent")
            
            class Query(BaseModel):
                message: str
            
            @app.post("/chat")
            def chat(query: Query):
                result = agent.run(query.message)
                return {{"answer": result.answer, "strategy": result.strategy_used}}
            
            @app.get("/health")
            def health():
                return {{"status": "ok"}}
            
            print(f"Starting server on port {{args.port}}...")
            uvicorn.run(app, host="0.0.0.0", port=args.port)
            
        except ImportError:
            print("Error: API server requires: pip install fastapi uvicorn")
            sys.exit(1)
    
    elif args.query:
        result = agent.run(args.query)
        print(result.answer)
    
    else:
        # Interactive mode
        print(f"OnsetLab Agent ({{agent.model_name}})")
        print("Type 'quit' to exit")
        print()
        
        while True:
            try:
                query = input("You: ").strip()
                if query.lower() in ["quit", "exit", "q"]:
                    break
                if not query:
                    continue
                
                result = agent.run(query)
                print(f"Agent: {{result.answer}}")
                print()
            except KeyboardInterrupt:
                break
            except EOFError:
                break
        
        print("Goodbye!")

if __name__ == "__main__":
    main()
'''


class BinaryExporter:
    """Export agent as standalone executable."""
    
    @classmethod
    def export(
        cls,
        agent,
        output: str,
        use_pyinstaller: bool = False,
    ) -> str:
        """
        Export agent as standalone script or binary.
        
        Args:
            agent: Agent instance
            output: Output path
            use_pyinstaller: Create actual binary with PyInstaller
            
        Returns:
            Path to exported file
        """
        output_path = Path(output)
        
        # Extract config
        config = ConfigExporter._extract_config(agent, include_mcp_auth=False)
        
        # Generate standalone script
        script_content = STANDALONE_SCRIPT.format(
            model=agent.model_name,
            config=repr(config),
        )
        
        if use_pyinstaller:
            return cls._create_binary(script_content, output_path, agent.model_name)
        else:
            return cls._create_script(script_content, output_path)
    
    @classmethod
    def _create_script(cls, content: str, output_path: Path) -> str:
        """Create standalone Python script."""
        # Ensure .py extension
        if output_path.suffix != ".py":
            output_path = output_path.with_suffix(".py")
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, "w") as f:
            f.write(content)
        
        # Make executable on Unix
        if sys.platform != "win32":
            os.chmod(output_path, 0o755)
        
        return str(output_path)
    
    @classmethod
    def _create_binary(cls, content: str, output_path: Path, model_name: str) -> str:
        """Create binary using PyInstaller."""
        try:
            import PyInstaller.__main__
        except ImportError:
            raise ImportError(
                "PyInstaller not installed. Install with: pip install pyinstaller\n"
                "Or use export without use_pyinstaller=True for a Python script."
            )
        
        # Create temp directory for build
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir_path = Path(tmpdir)
            
            # Write script
            script_path = tmpdir_path / "agent.py"
            with open(script_path, "w") as f:
                f.write(content)
            
            # Determine output name
            if output_path.suffix:
                output_name = output_path.stem
                output_dir = output_path.parent
            else:
                output_name = output_path.name
                output_dir = output_path.parent
            
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Run PyInstaller
            PyInstaller.__main__.run([
                str(script_path),
                "--onefile",
                "--name", output_name,
                "--distpath", str(output_dir),
                "--workpath", str(tmpdir_path / "build"),
                "--specpath", str(tmpdir_path),
                "--clean",
                "--noconfirm",
            ])
            
            # Return path to binary
            if sys.platform == "win32":
                return str(output_dir / f"{output_name}.exe")
            else:
                return str(output_dir / output_name)
