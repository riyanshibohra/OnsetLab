#!/usr/bin/env python3
"""
OnsetLab Agent
==============
AI agent powered by LLM API + MCP servers.
Generated by OnsetLab - https://github.com/yourusername/onsetlab
"""

import os
import json
import asyncio
import re
from pathlib import Path
from typing import Optional
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

# ============================================================================
# Load Configuration
# ============================================================================

_dir = Path(__file__).parent

with open(_dir / "config.json") as f:
    CONFIG = json.load(f)

with open(_dir / "tools.json") as f:
    TOOLS = json.load(f)

with open(_dir / "mcp_config.json") as f:
    MCP_CONFIG = json.load(f)

AGENT_NAME = CONFIG.get("agent_name", "Assistant")
API_PROVIDER = CONFIG.get("api_provider", "openai")
MODEL = CONFIG.get("model", "gpt-4o")
SKILL_SUMMARY = CONFIG.get("skill_summary", "A helpful assistant.")

# Get current date/time for context
now = datetime.now()
current_datetime = now.strftime("%A, %B %d, %Y at %I:%M %p")
current_date = now.strftime("%Y-%m-%d")
current_time = now.strftime("%H:%M:%S")

SYSTEM_PROMPT = f"""You are {AGENT_NAME}, a helpful assistant.

CURRENT DATE & TIME:
- Full: {current_datetime}
- Date (YYYY-MM-DD): {current_date}
- Time (24h): {current_time}

{SKILL_SUMMARY}

When the user asks you to do something, use the appropriate tool.
For casual conversation (greetings, thanks, questions about yourself), respond naturally without tools.
Always be helpful and concise. Give clean, readable responses without excessive formatting.

For date/time-related requests:
- Use the current date/time above as reference
- "today" = {current_date}
- "this week" = next 7 days from {current_date}
- Calculate dates relative to {current_date}
"""


# ============================================================================
# Utility Functions
# ============================================================================

def clean_response(text: str) -> str:
    """Clean up markdown and formatting from response."""
    if not text:
        return text
    
    # Remove excessive asterisks (bold/italic markers)
    text = re.sub(r'\*{2,}', '', text)
    text = re.sub(r'(?<!\*)\*(?!\*)', '', text)
    
    # Clean up excessive newlines
    text = re.sub(r'\n{3,}', '\n\n', text)
    
    return text.strip()


def convert_tool_schema(tool: dict) -> tuple[dict, list]:
    """Convert tool schema to OpenAI/Anthropic format."""
    params = tool.get("parameters", {})
    properties = {}
    required = []
    
    for param_name, param_def in params.items():
        if isinstance(param_def, dict):
            clean_param = {"type": param_def.get("type", "string")}
            
            if "description" in param_def:
                clean_param["description"] = param_def["description"]
            if "enum" in param_def:
                clean_param["enum"] = param_def["enum"]
            if param_def.get("type") == "array":
                clean_param["items"] = param_def.get("items", {"type": "string"})
            if "default" in param_def:
                clean_param["default"] = param_def["default"]
            if param_def.get("type") == "object" and "properties" in param_def:
                clean_param["properties"] = param_def["properties"]
            
            properties[param_name] = clean_param
            
            if param_def.get("required", False):
                required.append(param_name)
    
    for rp in tool.get("required_params", []):
        if rp not in required:
            required.append(rp)
    
    return properties, required


# ============================================================================
# MCP Client
# ============================================================================

class MCPToolExecutor:
    """Executes tools via MCP servers."""
    
    def __init__(self):
        self.processes = {}
        self.readers = {}
        self.writers = {}
        self.stderr_tasks = {}
        self.request_id = 0
    
    def _next_id(self) -> int:
        self.request_id += 1
        return self.request_id
    
    async def start_servers(self):
        """Start all configured MCP servers."""
        for server in MCP_CONFIG:
            name = server.get("name", server.get("service", "unknown"))
            pkg = server.get("package", {})
            pkg_type = pkg.get("type", "npm")
            
            try:
                command = pkg.get("command", "")
                args = pkg.get("args", [])
                
                if pkg_type == "docker" and command == "docker":
                    cmd = [command] + args
                elif pkg_type == "docker":
                    image = pkg.get("image", "")
                    env_args = []
                    for env_var in server.get("auth", {}).get("env_vars", []):
                        val = os.environ.get(env_var, "")
                        if val:
                            env_args.extend(["-e", f"{env_var}={val}"])
                    cmd = ["docker", "run", "-i", "--rm", "--pull", "always"] + env_args + [image]
                elif pkg_type in ("npm", "binary"):
                    if command and args:
                        cmd = [command] + args
                    else:
                        cmd = ["npx", "-y", pkg.get("name", "")]
                else:
                    continue
                
                env = os.environ.copy()
                for env_var in server.get("auth", {}).get("env_vars", []):
                    if env_var in os.environ:
                        env[env_var] = os.environ[env_var]
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdin=asyncio.subprocess.PIPE,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    env=env
                )
                
                self.processes[name] = process
                self.readers[name] = process.stdout
                self.writers[name] = process.stdin
                
                self.stderr_tasks[name] = asyncio.create_task(
                    self._read_stderr(name, process.stderr)
                )
                
                success = await self._initialize_server(name)
                if success:
                    print(f"  ✓ {name}")
                else:
                    print(f"  ✗ {name} (failed to initialize)")
                
            except Exception as e:
                print(f"  ✗ {name} ({e})")
    
    async def _read_stderr(self, name: str, stderr):
        """Read stderr (silent unless error)."""
        try:
            while True:
                line = await stderr.readline()
                if not line:
                    break
        except Exception:
            pass
    
    async def _initialize_server(self, name: str) -> bool:
        """Initialize MCP connection."""
        req_id = self._next_id()
        init_msg = {
            "jsonrpc": "2.0",
            "id": req_id,
            "method": "initialize",
            "params": {
                "protocolVersion": "2024-11-05",
                "capabilities": {},
                "clientInfo": {"name": AGENT_NAME, "version": "1.0.0"}
            }
        }
        await self._send_message(name, init_msg)
        
        response = await self._read_message(name, timeout=120.0)
        if not response:
            return False
        
        await self._send_message(name, {
            "jsonrpc": "2.0",
            "method": "notifications/initialized"
        })
        
        await asyncio.sleep(0.5)
        return True
    
    async def _send_message(self, name: str, msg: dict):
        """Send JSON-RPC message."""
        if name not in self.writers:
            return
        writer = self.writers[name]
        data = json.dumps(msg) + "\n"
        writer.write(data.encode())
        await writer.drain()
    
    async def _read_message(self, name: str, timeout: float = 30.0) -> Optional[dict]:
        """Read JSON-RPC message."""
        if name not in self.readers:
            return None
        reader = self.readers[name]
        try:
            line = await asyncio.wait_for(reader.readline(), timeout=timeout)
            if line:
                return json.loads(line.decode())
        except (asyncio.TimeoutError, json.JSONDecodeError):
            pass
        return None
    
    async def call_tool(self, tool_name: str, arguments: dict) -> str:
        """Execute a tool via MCP."""
        server_name = None
        for server in MCP_CONFIG:
            tools = server.get("tools", [])
            tool_names = [t.get("name") if isinstance(t, dict) else t for t in tools]
            if tool_name in tool_names:
                server_name = server.get("name", server.get("service"))
                break
        
        if not server_name or server_name not in self.writers:
            return json.dumps({"error": f"Tool {tool_name} not available"})
        
        req_id = self._next_id()
        msg = {
            "jsonrpc": "2.0",
            "id": req_id,
            "method": "tools/call",
            "params": {"name": tool_name, "arguments": arguments}
        }
        await self._send_message(server_name, msg)
        
        for _ in range(10):
            response = await self._read_message(server_name, timeout=60.0)
            if not response:
                return json.dumps({"error": "No response from tool"})
            
            if response.get("id") == req_id:
                if "error" in response:
                    return json.dumps({"error": response["error"].get("message", "Unknown error")})
                if "result" in response:
                    content = response["result"].get("content", [])
                    if content and len(content) > 0:
                        return content[0].get("text", json.dumps(content))
                    return json.dumps(response["result"])
        
        return json.dumps({"error": "Timeout waiting for tool response"})
    
    async def stop_servers(self):
        """Stop all MCP servers."""
        for task in self.stderr_tasks.values():
            task.cancel()
        
        for name, process in self.processes.items():
            try:
                process.terminate()
                await asyncio.wait_for(process.wait(), timeout=5.0)
            except:
                try:
                    process.kill()
                except:
                    pass


# ============================================================================
# API Clients
# ============================================================================

def get_openai_completion(messages: list, tools: list):
    """Get completion from OpenAI."""
    from openai import OpenAI
    client = OpenAI()
    
    openai_tools = []
    for tool in tools:
        properties, required = convert_tool_schema(tool)
        openai_tools.append({
            "type": "function",
            "function": {
                "name": tool["name"],
                "description": tool.get("description", ""),
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required
                }
            }
        })
    
    response = client.chat.completions.create(
        model=MODEL,
        messages=messages,
        tools=openai_tools if openai_tools else None,
        tool_choice="auto" if openai_tools else None
    )
    
    return response.choices[0]


def get_anthropic_completion(messages: list, tools: list):
    """Get completion from Anthropic."""
    from anthropic import Anthropic
    client = Anthropic()
    
    anthropic_tools = []
    for tool in tools:
        properties, required = convert_tool_schema(tool)
        anthropic_tools.append({
            "name": tool["name"],
            "description": tool.get("description", ""),
            "input_schema": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        })
    
    system = ""
    chat_messages = []
    for msg in messages:
        if msg["role"] == "system":
            system = msg["content"]
        else:
            chat_messages.append(msg)
    
    response = client.messages.create(
        model=MODEL,
        max_tokens=4096,
        system=system,
        messages=chat_messages,
        tools=anthropic_tools if anthropic_tools else None
    )
    
    return response


# ============================================================================
# Main Agent Loop
# ============================================================================

async def run_agent():
    """Main agent loop."""
    print(f"\n{'='*50}")
    print(f"  {AGENT_NAME}")
    print(f"  Model: {MODEL} | Tools: {len(TOOLS)}")
    print(f"{'='*50}")
    
    executor = MCPToolExecutor()
    print("\nConnecting to services...")
    await executor.start_servers()
    print()
    
    messages = [{"role": "system", "content": SYSTEM_PROMPT}]
    
    try:
        while True:
            user_input = input("You: ").strip()
            if user_input.lower() in ("quit", "exit", "q"):
                print("Goodbye!")
                break
            if not user_input:
                continue
            
            messages.append({"role": "user", "content": user_input})
            
            if API_PROVIDER == "openai":
                response = get_openai_completion(messages, TOOLS)
                
                if response.message.tool_calls:
                    for tool_call in response.message.tool_calls:
                        tool_name = tool_call.function.name
                        try:
                            args = json.loads(tool_call.function.arguments)
                        except:
                            args = {}
                        
                        print(f"  [Using {tool_name}...]")
                        result = await executor.call_tool(tool_name, args)
                        
                        messages.append({
                            "role": "assistant",
                            "content": None,
                            "tool_calls": [{
                                "id": tool_call.id,
                                "type": "function",
                                "function": {
                                    "name": tool_name,
                                    "arguments": tool_call.function.arguments
                                }
                            }]
                        })
                        messages.append({
                            "role": "tool",
                            "tool_call_id": tool_call.id,
                            "content": result
                        })
                    
                    response = get_openai_completion(messages, TOOLS)
                
                assistant_message = response.message.content or ""
                
            else:  # anthropic
                response = get_anthropic_completion(messages, TOOLS)
                
                tool_results = []
                for block in response.content:
                    if block.type == "tool_use":
                        tool_name = block.name
                        args = block.input
                        
                        print(f"  [Using {tool_name}...]")
                        result = await executor.call_tool(tool_name, args)
                        
                        tool_results.append({
                            "type": "tool_result",
                            "tool_use_id": block.id,
                            "content": result
                        })
                
                if tool_results:
                    messages.append({"role": "assistant", "content": response.content})
                    messages.append({"role": "user", "content": tool_results})
                    response = get_anthropic_completion(messages, TOOLS)
                
                assistant_message = ""
                for block in response.content:
                    if hasattr(block, "text"):
                        assistant_message += block.text
            
            # Clean and display response
            clean_msg = clean_response(assistant_message)
            print(f"\nAssistant: {clean_msg}\n")
            messages.append({"role": "assistant", "content": assistant_message})
            
    except KeyboardInterrupt:
        print("\n\nGoodbye!")
    finally:
        await executor.stop_servers()


if __name__ == "__main__":
    asyncio.run(run_agent())
